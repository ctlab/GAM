Genomic and metabolomic integrated analysis tutorial
====================================================
This is a small tutorial that describes how having metabolic mass-spectrometry
data and genomic expression data for two conditions one can find the most
significant changed module in the metabolite reactions network.

Quick start
----------------------------------------------------

This section shows basics of the GAM package using genomic and metabolic data
for mouse macrophages under different treatments. Package includes both these data
and already constructed mouse network   

```{r}
library("GAM")
data("mouse.macrophages")
data("kegg.mouse.network")
```

The data contains precalculated differential expression values between M1 and M2 
states:
```{r}
head(mouse.macrophages$gene.de.M1.M2)
head(mouse.macrophages$met.de.M1.M2)
```

Mouse network is actually a list of triples `met.x`, `rxn` and `met.y`,
each of its elements says that compounds `met.x`
and `met.y` are on different sides of the reaction `rxn`.
```{r}
head(kegg.mouse.network$graph.raw)
```


Next step is to make an experiment set that contains all the data 
necessary to find modules. It is done by calling a function
`makeExperimentSet` which accepts as arguments network,
available differential expression data, and type of IDs that is
used in this data. One part of preprocessing is to fir p-values distribution
to beta-uniform model, by default `makeEXperimentSet` makes histogram and QQ-plot,
so one can check if it fits good enough.
```{r chache=TRUE, error=FALSE, message=FALSE}
es <- makeExperimentSet(network=kegg.mouse.network,
                        met.de=mouse.macrophages$met.de.M1.M2,
                        gene.de=mouse.macrophages$gene.de.M1.M2,
                        met.ids=mouse.macrophages$met.ids, 
                        gene.ids=mouse.macrophages$gene.ids)
```

Result contains gene and metabolite differential expression with
converted IDs, p-values for reactions and subnetwork with only
those reactions that have expressed genes for enzymes.
```{r}
head(es$gene.de)
head(es$met.de)
head(es$rxn.de)
es$subnet
```


To be able to find modules `GAM` need solver for maximum-wight
connected subgraph problem. [Heinz](http://www.mi.fu-berlin.de/w/LiSA/Heinz) 
is used for this purpose. Directory with heinz should also contain a license file
for CPLEX.
```{r}
heinz.py <- "~/lib/heinz/heinz.py"
list.files(dirname(heinz.py))
```

Set FDRs and score for absent metabolites. Using these parameters size of the module
can be controlled: larger FDRs make larger modules. Score for absnet metabolites controls
how many such metabolites will be in the module.
```{r}
met.fdr=c(1e-6)
gene.fdr=c(1e-6)
absent.met.score=c(-20)
```

And now we can finally find most significant module in our network.
```{r chache=TRUE, error=FALSE}
modules <- findModules(es,
                       met.fdr=met.fdr,
                       gene.fdr=gene.fdr,
                       absent.met.score=absent.met.score,
                       heinz.py=heinz.py,                                
                       heinz.nModules=1                       
)
module <- modules[[1]]
module
```

One can plot this module using command `plotNetwork`.
```{r fig.width=16,fig.height=16,error=FALSE,message=FALSE}
plotNetwork(module)
```

One can do some post-processing steps that will help with representation.
These steps include adding all metabolites taking part in every reaction:
```{r fig.width=16,fig.height=16,error=FALSE,message=FALSE}
module <- addMetabolitesForReactions(module, es)
plotNetwork(module)
```

Adding all reactions that connect any metabolites in the module.
```{r fig.width=16,fig.height=16,error=FALSE,message=FALSE}
module <- addInterconnections(module, es)
plotNetwork(module)
```

Adding attribute for log-fold change normalized across nodes of the
same type. Thist attribute is used in `plotNetwork` function and 
Cytoscape vizual style.
```{r fig.width=16,fig.height=16,error=FALSE,message=FALSE}
module <- addNormLogFC(module)
plotNetwork(module)
```

Removing hanging nodes without p-values.
```{r fig.width=16,fig.height=16,error=FALSE,message=FALSE}
module <- removeHangingNodes(module)
plotNetwork(module)
```

Replacing reaction nodes for simple one-to-one reactions with
edges and copying reaction attributes for edges adjacent to 
reaction nodes.
```{r fig.width=16,fig.height=16,error=FALSE,message=FALSE}
module <- removeSimpleReactions(module, es)
module <- expandReactionNodeAttributesToEdges(module)
plotNetwork(module)
```
     
After post-processing stage one can save resulting module into pdf, XGMML
or few other formats.
```{r error=FALSE}
saveModule(module,
           paste0("module.M1.M2", 
                  ".mf=", met.fdr,
                  ".rf=", gene.fdr,
                  ".ms=", absent.met.score),
           types=c("pdf", "XGMML")
)
```
     
 
Computing differential expression
--------------------------------------------------

The package have functions to ease computing differential expression using DESeq or limma packages.

```{r cache=TRUE, error=FALSE}
str(as.matrix(mouse.macrophages$gene.exprs))
str(mouse.macrophages$gene.conditions.vector)

str(as.matrix(mouse.macrophages$met.exprs))
str(mouse.macrophages$met.conditions.vector)

state1 <- "MandLPSandIFNg"
state2 <- "MandIL4"

gene.de.M1.M2 <- diffExpr(
    exprs=mouse.macrophages$gene.exprs, conditions.vector=mouse.macrophages$gene.conditions.vector,
    state1=state1, state2=state2, use.deseq=T, top=20000)

head(gene.de.M1.M2)

met.de.M1.M2 <- diffExpr(
    exprs=mouse.macrophages$met.exprs, conditions.vector=mouse.macrophages$met.conditions.vector,
    state1=state1, state2=state2, 
    log2=F, quantile=F, use.deseq=F, top=Inf)

head(met.de.M1.M2)
```

Constructing network
-------------------------------------------------

Network construction heavily uses KEGG database. `GAM` package goes with
neccessary parts of KEGG in `kegg.db` object:

```{r}
data(kegg.db)
names(kegg.db)
```

It includes mapping from reaction to its enzymes and mapping from enzym to its coding genes
(now just for mouse and human):
```{r}
head(kegg.db$rxn2enz)
head(kegg.db$enz2gene)
```

Connections between metabolites on different sides of reactions:
```{r}
head(kegg.db$net)
```

Names for reactions and metabolites. In analysis names of reaction genes are
usually used as reaction labels, not reaction names.
```{r}
head(kegg.db$rxn2name)
head(kegg.db$met2name)
```

Metabolites and reactions to mask. Masked metabolites are non-organic molecules, 
some generic molecules and some others. Masked reactions are reactions that 
are parts of multi-step reactions.
```{r}
head(kegg.db$mets2mask)
head(kegg.db$rxns2mask)
```

Some of metabolites, e.g. anomeric ones, can be collaps into one node.
```{r}
head(kegg.db$mets2collapse)
```

From all this data one can make a network for a specific organism with
`makeKeggNetwork` function:
```{r cache=TRUE}
kegg.mouse.network <- makeKeggNetwork(kegg.db, "MMU")
```

All of these data can be modified for specific needs. For example,
one can add reaction converting cis-Aconitate to Itaconate which
was not present in KEGG as for September 2013:
```{r cache=TRUE}
kegg.db$net <- rbind(kegg.db$net, c("C00417", "RXIRG1", "C00490"))
kegg.db$rxn2enz <- rbind(kegg.db$rxn2enz, c("RXIRG1", "Irg1"))
kegg.db$enz2gene <- rbind(kegg.db$enz2gene, c("Irg1", "16365", "MMU"))
kegg.mouse.network <- makeKeggNetwork(kegg.db, "MMU")
```
     
Adding attributes to modules
----------------------------------------

Sometimes it useful to add additional attributes to the module. For example
it may be interesting to add p-values and log-fold change for metabolites
and reactions also for M0 vs. M1 and M0 vs. M2. There are no special functions
for this in the package but it can be done pretty straightforward but first 
one has to have data with the same IDs as in network:

```{r cache=TRUE}
data(gene.id.map)
data(met.id.map)
gene.de.M0.M1 <- convertPval(mouse.macrophages$gene.de.M0.M1, gene.id.map$RefSeq, gene.id.map$Entrez)
met.de.M0.M1 <- convertPval(mouse.macrophages$met.de.M0.M1, met.id.map$HMDB, met.id.map$KEGG)
gene.de.M0.M2 <- convertPval(mouse.macrophages$gene.de.M0.M2, gene.id.map$RefSeq, gene.id.map$Entrez)
met.de.M0.M2 <- convertPval(mouse.macrophages$met.de.M0.M2, met.id.map$HMDB, met.id.map$KEGG)
```

Then one can add this data as attributes to the modules. The only thing to remember is
that `graphNEL` doesn't store attributes for reverse edges, even when a graph is not
directed.

```{r cache=TRUE}
for (attr in c("pval", "logFC")) {            
    edges <- edgelist(module)            
    edges <- edges[!is.na(edgeData(module, from=edges$u, to=edges$v, attr="origin")),]

    
    new.attr <- paste0(attr, ".M0.M1")
    nodeDataDefaults(module, new.attr) <- NA
    nodeData(module, attr=new.attr) <-
        met.de.M0.M1[
            match(nodes(module),
                  met.de.M0.M1$ID),
            attr]
    
    edgeDataDefaults(module, new.attr) <- NA
    edgeData(module, from=edges$u, to=edges$v, attr=new.attr) <- 
        gene.de.M0.M1[
            match(
                unlist(edgeData(
                    module, 
                    from=edges$u,
                    to=edges$v,
                    attr="origin")), 
                gene.de.M0.M1$ID),
            attr]    
    
    new.attr <- paste0(attr, ".M0.M2")
    nodeDataDefaults(module, new.attr) <- NA
    nodeData(module, attr=new.attr) <-
        met.de.M0.M2[
            match(
                nodes(module), 
                met.de.M0.M2$ID),
            attr]
    
    edgeDataDefaults(module, new.attr) <- NA
    edgeData(module, from=edges$u, to=edges$v, attr=new.attr) <- 
        gene.de.M0.M2[
            match(
                unlist(edgeData(
                    module, 
                    from=edges$u,
                    to=edges$v,
                    attr="origin")), 
                gene.de.M0.M2$ID),
            attr]    
}

nodeData(module)[[1]]
edgeData(module)[[1]]
```