Genomic and metabolomic integrated analysis tutorial
====================================================
This is a small tutorial that describes how having metabolic mass-spectrometry
data and genomic expression data for two conditions one can find the most
significant changed module in the metabolite reactions network.

Quick start
----------------------------------------------------

This section shows basics of the GAM package using genomic and metabolic data
for mouse macrophages under different treatments. Package includes both these data
and already constructed mouse network   

```{r}
library("GAM")
data("mouse.macrophages")
data("kegg.mouse.network")
```

The data contains precalculated differential expression values between M1 and M2 
states:
```{r}
head(mouse.macrophages$gene.de.M1.M2)
head(mouse.macrophages$met.de.M1.M2)
```

Mouse network is actually a list of triples `met.x`, `rxn` and `met.y`,
each of its elements says that compounds `met.x`
and `met.y` are on different sides of the reaction `rxn`.
```{r}
head(kegg.mouse.network$graph.raw)
```


Next step is to make an experiment set that contains all the data 
necessary to find modules. It is done by calling a function
`makeExperimentSet` which accepts as arguments network,
available differential expression data, and type of IDs that is
used in this data. One part of preprocessing is to fir p-values distribution
to beta-uniform model, by default `makeEXperimentSet` makes histogram and QQ-plot,
so one can check if it fits good enough.
```{r cache=TRUE,message=FALSE}
es <- makeExperimentSet(network=kegg.mouse.network,
                        met.de=mouse.macrophages$met.de.M1.M2,
                        gene.de=mouse.macrophages$gene.de.M1.M2,
                        met.ids=mouse.macrophages$met.ids, 
                        gene.ids=mouse.macrophages$gene.ids)
```

Result contains gene and metabolite differential expression with
converted IDs, p-values for reactions and subnetwork with only
those reactions that have expressed genes for enzymes.
```{r}
head(es$gene.de)
head(es$met.de)
head(es$rxn.de)
es$subnet
```


To be able to find modules `GAM` need solver for maximum-wight
connected subgraph problem. [Heinz](http://www.mi.fu-berlin.de/w/LiSA/Heinz) 
is used for this purpose. Directory with heinz should also contain a license file
for CPLEX.
```{r}
heinz.py <- "~/lib/heinz/heinz.py"
list.files(dirname(heinz.py))
```

Set FDRs and score for absent metabolites. Using these parameters size of the module
can be controlled: larger FDRs make larger modules. Score for absnet metabolites controls
how many such metabolites will be in the module.
```{r}
met.fdr=c(1e-5)
gene.fdr=c(1e-5)
absent.met.score=c(-10)
```

And now we can finally find most significant module in our network.
```{r chache=TRUE}
modules <- findModules(es,
                       met.fdr=met.fdr,
                       gene.fdr=gene.fdr,
                       absent.met.score=absent.met.score,
                       heinz.py=heinz.py,                                
                       heinz.nModules=1                       
)
module <- modules[[1]]
module
```

One can plot this module using command `plotNetwork` 
or save it to different formats using `saveModule`.
```{r fig.width=16,fig.height=16,error=FALSE,message=FALSE}
plotNetwork(module)
saveModule(module,
           paste0("module.M1.M2", 
                  ".mf=", met.fdr,
                  ".rf=", gene.fdr,
                  ".ms=", absent.met.score),
           types=c("pdf", "XGMML")
)
```

     
     
     
Adding attributes to modules
----------------------------------------

Sometimes it useful to add additional attributes to the module. For example
it may be interesting to add p-values and log-fold change for metabolites
and reactions also for M0 vs. M1 and M0 vs. M2. There are no special functions
for this in the package but it can be done pretty straightforward but first 
you have to have data with the same IDs as in network:

```{r cache=TRUE}
data(gene.id.map)
data(met.id.map)
gene.de.M0.M1 <- convertPval(mouse.macrophages$gene.de.M0.M1, gene.id.map$RefSeq, gene.id.map$Entrez)
met.de.M0.M1 <- convertPval(mouse.macrophages$met.de.M0.M1, met.id.map$HMDB, met.id.map$KEGG)
gene.de.M0.M2 <- convertPval(mouse.macrophages$gene.de.M0.M2, gene.id.map$RefSeq, gene.id.map$Entrez)
met.de.M0.M2 <- convertPval(mouse.macrophages$met.de.M0.M2, met.id.map$HMDB, met.id.map$KEGG)
```

Then one can add this data as attributes to the modules. The only thing to remember is
that `graphNEL` doesn't store attributes for reverse edges, even when a graph is not
directed.

```{r cache=TRUE}
for (attr in c("pval", "logFC")) {            
    edges <- edgelist(module)            
    edges <- edges[!is.na(edgeData(module, from=edges$u, to=edges$v, attr="origin")),]

    
    new.attr <- paste0(attr, ".M0.M1")
    nodeDataDefaults(module, new.attr) <- NA
    nodeData(module, attr=new.attr) <-
        met.de.M0.M1[
            match(nodes(module),
                  met.de.M0.M1$ID),
            attr]
    
    edgeDataDefaults(module, new.attr) <- NA
    edgeData(module, from=edges$u, to=edges$v, attr=new.attr) <- 
        gene.de.M0.M1[
            match(
                unlist(edgeData(
                    module, 
                    from=edges$u,
                    to=edges$v,
                    attr="origin")), 
                gene.de.M0.M1$ID),
            attr]    
    
    new.attr <- paste0(attr, ".M0.M2")
    nodeDataDefaults(module, new.attr) <- NA
    nodeData(module, attr=new.attr) <-
        met.de.M0.M2[
            match(
                nodes(module), 
                met.de.M0.M2$ID),
            attr]
    
    edgeDataDefaults(module, new.attr) <- NA
    edgeData(module, from=edges$u, to=edges$v, attr=new.attr) <- 
        gene.de.M0.M2[
            match(
                unlist(edgeData(
                    module, 
                    from=edges$u,
                    to=edges$v,
                    attr="origin")), 
                gene.de.M0.M2$ID),
            attr]    
}

nodeData(module)[[1]]
edgeData(module)[[1]]
```
 
Computing differential expression
--------------------------------------------------


```{r}
# The dataset consists of gene expression data,
str(mouse.macrophages$gene.exprs)

# conditions vector for gene,
str(mouse.macrophages$gene.conditions.vector)

# metabolite mass-spectrometry data,
str(mouse.macrophages$met.exprs)

#conditions vector for metabolites,
str(mouse.macrophages$met.conditions.vector)
```

Constructing network
-------------------------------------------------
